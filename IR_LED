/* IR LED + Phototransistor (direct) — ESP32 / Arduino IDE
 * Detects a change greater than ±5% from baseline (LED-on minus LED-off),
 * regardless of the baseline being positive or negative.
 */

#define IR_LED_PIN        25
#define SENSOR_PIN        34
#define STATUS_LED_PIN     2

// -------------------- TUNABLES --------------------
const uint8_t  ADC_BITS               = 12;
const adc_attenuation_t ADC_ATTEN     = ADC_11db;
const uint16_t LED_SETTLE_US          = 50;
const uint8_t  SAMPLES_PER_PHASE      = 2;
const uint16_t CAL_TIME_MS            = 3000;

// ±5% change detection
const float    MIN_RELATIVE_DELTA     = 0.1f;

// Hysteresis + debounce
const uint16_t HYSTERESIS_COUNTS      = 20;
const uint8_t  DEBOUNCE_HITS_REQUIRED = 1;
const uint8_t  DEBOUNCE_CLEAR_REQUIRED= 3;
const uint16_t LOOP_PERIOD_MS         = 1;

// -------------------- RUNTIME STATE --------------------
float    baseline = 0.0f;
float    noiseStd = 5.0f;  // just for info printing
float    threshUp = 0.0f;  // baseline + 10%
float    threshDn = 0.0f;  // baseline - 10%
bool     detected = false;
uint8_t  hitCount = 0;
uint8_t  clearCount = 0;

const float EMA_ALPHA = 0.25f;
float emaDiff = 0.0f;

// -------------------- HELPERS --------------------
uint16_t readADC() {
  return analogRead(SENSOR_PIN);
}

// LED ON/OFF differenced reading
int16_t readDifferenced() {
  // LED ON phase
  digitalWrite(IR_LED_PIN, HIGH);
  delayMicroseconds(LED_SETTLE_US);
  uint32_t sumOn = 0;
  for (uint8_t i = 0; i < SAMPLES_PER_PHASE; ++i) {
    sumOn += readADC();
  }

  // LED OFF phase
  digitalWrite(IR_LED_PIN, LOW);
  delayMicroseconds(LED_SETTLE_US);
  uint32_t sumOff = 0;
  for (uint8_t i = 0; i < SAMPLES_PER_PHASE; ++i) {
    sumOff += readADC();
  }

  int32_t avgOn  = (int32_t)(sumOn  / SAMPLES_PER_PHASE);
  int32_t avgOff = (int32_t)(sumOff / SAMPLES_PER_PHASE);
  return (int16_t)(avgOn - avgOff);
}

// Compute ±5% thresholds (no clamping; allow negative baselines)
void computeThresholds() {
  float margin = MIN_RELATIVE_DELTA * fabsf(baseline);  // exactly 5% of |baseline|
  threshUp = baseline + margin;
  threshDn = baseline - margin;
}

void autoCalibrate() {
  const uint32_t tStart = millis();
  uint32_t n = 0;
  double mean = 0.0;
  double M2   = 0.0;

  while ((millis() - tStart) < CAL_TIME_MS) {
    int16_t d = readDifferenced();
    n++;
    double x = (double)d;
    double delta  = x - mean;
    mean += delta / (double)n;
    double delta2 = x - mean;
    M2 += delta * delta2;

    //delay(LOOP_PERIOD_MS);
  }

  if (n > 1) {
    baseline = (float)mean;
    noiseStd = (float)sqrt(M2 / (double)(n - 1));
  } else {
    baseline = 0.0f;
    noiseStd = 0.0f;
  }

  emaDiff = baseline;
  computeThresholds();

  Serial.println(F("\n== Auto-Calibration Complete =="));
  Serial.print(F("Samples: "));   Serial.println((uint32_t)n);
  Serial.print(F("Baseline: "));  Serial.println(baseline, 2);
  Serial.print(F("Noise σ: "));   Serial.println(noiseStd, 2);
  Serial.print(F("ThreshUp: "));  Serial.println(threshUp, 2);
  Serial.print(F("ThreshDn: "));  Serial.println(threshDn, 2);
  Serial.print(F("Delta %: "));   Serial.println(MIN_RELATIVE_DELTA * 100.0f, 2);
  Serial.println(F("================================\n"));
}

// -------------------- SETUP --------------------
void setup() {
  Serial.begin(115200);
  delay(200);

  pinMode(IR_LED_PIN, OUTPUT);
  digitalWrite(IR_LED_PIN, LOW);

  pinMode(STATUS_LED_PIN, OUTPUT);
  digitalWrite(STATUS_LED_PIN, LOW);

  analogReadResolution(ADC_BITS);
  analogSetAttenuation(ADC_ATTEN);

  Serial.println(F("\nIR Phototransistor — ±5% change detector\n"));
  Serial.println(F("Calibrating... keep beam clear.\n"));

  autoCalibrate();
}

// -------------------- LOOP --------------------
void loop() {
  int16_t diff = readDifferenced();
  emaDiff = EMA_ALPHA * diff + (1.0f - EMA_ALPHA) * emaDiff;

  // Define the band and hysteresis in float
  float enterLow  = threshDn;
  float enterHigh = threshUp;
  float exitLow   = threshDn + (float)HYSTERESIS_COUNTS;
  float exitHigh  = threshUp - (float)HYSTERESIS_COUNTS;

  // ------ ON detection: outside ±5% band ------
  if (!detected) {
    if ((float)diff <= enterLow || (float)diff >= enterHigh) {
      if (++hitCount >= DEBOUNCE_HITS_REQUIRED) {
        detected   = true;
        hitCount   = 0;
        clearCount = 0;
        digitalWrite(STATUS_LED_PIN, HIGH);
        Serial.println(F("DETECTED (|Δ| > 5%)"));
      }
    } else {
      hitCount = 0;
    }
  }
  // ------ OFF detection: back inside band (with hysteresis) ------
  else {
    if ((float)diff > exitLow && (float)diff < exitHigh) {
      if (++clearCount >= DEBOUNCE_CLEAR_REQUIRED) {
        detected   = false;
        clearCount = 0;
        hitCount   = 0;
        digitalWrite(STATUS_LED_PIN, LOW);
        Serial.println(F("CLEARED (|Δ| ≤ 5%)"));
      }
    } else {
      clearCount = 0;
    }
  }

  // Debug print (includes % change)
  static uint32_t lastPrint = 0;
  uint32_t now = millis();
  if (now - lastPrint >= 100) {
    lastPrint = now;
    float delta      = (float)diff - baseline;
    float relChange  = (baseline != 0.0f) ? (delta / baseline * 100.0f) : 0.0f;

    Serial.print(F("diff="));   Serial.print(diff);
    Serial.print(F("  base=")); Serial.print(baseline, 2);
    Serial.print(F("  up="));   Serial.print(threshUp, 2);
    Serial.print(F("  dn="));   Serial.print(threshDn, 2);
    Serial.print(F("  d%="));   Serial.print(relChange, 2);
    Serial.print(F("  state="));Serial.println(detected ? F("ON") : F("OFF"));
  }

  delay(LOOP_PERIOD_MS);
}
